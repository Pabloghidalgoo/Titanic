import numpy as np
import pandas as pd
import numpy_financial as npf

def amortizacion_frances_mensualizada(
    principal: float,
    tasa_anual: float,
    total_meses: int,
    meses_entre_pagos: int,
    holidays: int,
    balloon: float = 0.0
) -> pd.DataFrame:
    """
    Tabla de amortización de un préstamo francés, en un DataFrame con filas mensuales.
    
    - principal: importe del préstamo
    - tasa_anual: tipo de interés nominal anual (por ejemplo 0.05)
    - total_meses: horizonte total en meses (filas del DataFrame)
    - meses_entre_pagos: 1,3,6,12 -> meses entre pagos (1=mensual,3=trimestral,6=semestral,12=anual)
    - holidays: nº de meses desde el inicio en los que NO se paga (carencia total),
                los pagos empiezan después de este periodo.
    - balloon: principal pendiente que se paga como importe "balloon" adicional
               en el último pago (mes del último pago periódico).
    """
    if holidays >= total_meses:
        raise ValueError("holidays debe ser menor que total_meses")
    
    if balloon < 0:
        raise ValueError("balloon no puede ser negativo")
    if balloon > principal:
        raise ValueError("balloon no puede ser mayor que el principal")
    
    # Tipo de interés por mes y por periodo de pago
    tasa_mensual = tasa_anual / 12.0
    tasa_periodo = (1 + tasa_mensual) ** meses_entre_pagos - 1
    
    # Número de pagos posibles en el horizonte después de holidays
    meses_restantes = total_meses - holidays
    n_pagos = meses_restantes // meses_entre_pagos  # pagos completos
    if n_pagos <= 0:
        raise ValueError("Con esos parámetros no hay ningún pago dentro del horizonte de meses.")
    
    # Anualidad a nivel de periodo de pago con valor futuro = balloon
    cuota_periodica = -npf.pmt(tasa_periodo, n_pagos, principal, fv=-balloon)
    
    # Interés y principal por periodo de pago (vectorizado)
    periodos = np.arange(1, n_pagos + 1)
    interes_por_periodo = -npf.ipmt(tasa_periodo, periodos, n_pagos, principal, fv=-balloon)
    principal_por_periodo = -npf.ppmt(tasa_periodo, periodos, n_pagos, principal, fv=-balloon)
    
    # Arrays mensuales
    meses = np.arange(1, total_meses + 1)
    pago_mensual = np.zeros(total_meses)
    interes_mensual = np.zeros(total_meses)
    principal_mensual = np.zeros(total_meses)
    
    # Meses en los que hay pago
    meses_pago = holidays + np.arange(1, n_pagos + 1) * meses_entre_pagos
    idx_meses_pago = meses_pago - 1  # 0-based
    
    # Pagos regulares
    pago_mensual[idx_meses_pago] = cuota_periodica
    interes_mensual[idx_meses_pago] = interes_por_periodo
    principal_mensual[idx_meses_pago] = principal_por_periodo
    
    # Añadimos el balloon al último pago
    idx_last = idx_meses_pago[-1]
    pago_mensual[idx_last] += balloon
    principal_mensual[idx_last] += balloon
    
    # Principal pendiente = principal inicial - principal acumulado pagado
    principal_pendiente_mensual = principal - principal_mensual.cumsum()
    principal_pendiente_mensual = np.maximum(principal_pendiente_mensual, 0)  # por si hay redondeos
    
    df = pd.DataFrame({
        "mes": meses,
        "pago": pago_mensual,
        "interes": interes_mensual,
        "principal_pagado": principal_mensual,
        "principal_pendiente": principal_pendiente_mensual
    })
    
    return df

# Ejemplo de uso con balloon
principal = 10_000
tasa_anual = 0.06
total_meses = 24          # 2 años
meses_entre_pagos = 3     # pagos trimestrales
holidays = 3              # 3 meses de carencia inicial
balloon = 2_000           # 2.000 € de principal en el último pago

df_ejemplo_balloon = amortizacion_frances_mensualizada(
    principal=principal,
    tasa_anual=tasa_anual,
    total_meses=total_meses,
    meses_entre_pagos=meses_entre_pagos,
    holidays=holidays,
    balloon=balloon
)

print(df_ejemplo_balloon)
